我们设计的 CPU 完整支持 RISC-V 的 RV32I 指令，还要加上压缩指令（C扩展）和乘除法（M扩展），实现的架构是 Tomasulo，并且带有简单的缓存和分支预测。

### 架构设计

我们在代码里实现了一个保留站（RS，8个条目），指令译码后先进入 RS “排队”，每条指令都会记录自己需要的数据来自哪里——如果数据已经准备好（在寄存器里），就直接记下值；如果数据还没算出来，就记下是哪条指令。只有两个源操作数都就绪了（ qj 和 qk 都是0），指令才会被送到空闲的 ALU（或者 AGU）执行。这样，即使前面的指令因为数据没到而卡住，后面不依赖它的指令也能先执行，实现了乱序。

我们还实现了一个重排序缓冲区（ROB，也是8个条目）。每一条新指令在发射后都会被分配一个ROB条目，记录它的状态。指令执行完先把结果存在 ROB 里，只有轮到它（成为ROB的头部）且确实完成了，才能把结果写回真正的寄存器文件或者写会内存。并且，在分支预测失败的时候，ROB 要负责发送清空信号。

访存操作（load/store）是性能瓶颈。我们设计了一个加载存储缓冲区（LSB，8个条目），它有几个重要功能：第一，store 指令可以先把数据放这里，不马上更新内存；第二，后续的 load 指令如果要读的地址和某个 store 冲突，就能直接从 LSB/DCache 拿到最新值，不用等 store写回内存；第三，多个 store 可以合并，减少访存次数。

我们采用了简单的分支预测，就是在两个分支中选择使得 PC 值最小的一个分治，也就是尽可能往前跳。这个简陋的分支预测在循环的时候预测准确率较高，在条件分支的时候预测准确率较低。

RISC-V 的 C 扩展（16位压缩指令）是为了节省代码空间，但给取指阶段带来了麻烦。因为指令长度可能是 16 位或 32 位混合的，地址可能不对齐。在我们的 ICache 实现中，取指逻辑要能识别当前取到的是半个指令还是一个完整指令，要小心计算下一条指令的地址。

RISC-V 的 M 扩展要求实现乘除法和取余，我们采用华莱士树计算乘法，采用 32 个周期的按位试商算法来实现除法和取余，为了避免长周期的计算操作导致 ALU 阻塞，我们设置了 8 个 ALU。

### 性能分析

在没有数据依赖和分支的情况下，几乎能做到每个周期发射一条指令，在有部分数据依赖的情况下，Tomasulo 算法也能处理依赖，让 CPU 不至于阻塞。

但是在乘除法操作存在依赖的时候就会出现阻塞，因为乘除法操作的执行周期较长，数据依赖没有解决就只能 bubble。分支预测失败的时候，flush 也会导致好几个周期的 bubble，和未提交指令的作废。

最后，我们实现了数据缓存（DCache），可以在一定程度上减少访存指令的 latency。

### 进一步的优化方向

可能能在以下方面优化：

- 实现一个更复杂的分支预测。
- 多发射。
- 把乘除法改造成流水线。
- 完善缓存系统。